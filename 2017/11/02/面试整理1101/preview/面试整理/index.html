<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | Awoke</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Awoke</h1><a id="logo" href="/.">Awoke</a><p class="description">记录下dq学习的点滴</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">Nov 2, 2017</div><div class="post-content"><html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>i5ting_ztree_toc:面试整理</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css">
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css">
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css">
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style="width:25%;">
						<ul id="tree" class="ztree" style="width:100%">

						</ul>
				</div>
        <div id="readme" style="width:70%;margin-left:20%;">
          	<article class="markdown-body">
            	<h1 id="-">面试整理</h1>
<h3 id="-">数据类型</h3>
<p>5种简单(基本)数据数据类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code></p>
<p>1种复杂数据类型：<code>Object</code></p>
<p>ES6新增了一种基本类型<code>Symbol</code>,实现唯一标识, 用法:</p>
<pre><code class="lang-JS">{
    // 1. 定义方式
    let id = Symbol(&#39;id&#39;);

    let user = {
        name: &#39;jack&#39;,
        [id]: 123 // symbol类型
    }

    // 2. Symbol 被 for…in 忽略

    // 3. Symbol.for, 读取定义的Symbol
    let id1 = Symbol.for(&quot;id&quot;);
    let id2 = Symbol.for(&quot;id&quot;);

    // true
    console.log(id1 === id2)

    // 4. Symbol.keyFor, 获取Symbol名字
    console.log(Symbol.keyFor(id2)) // 
}
</code></pre>
<p>JS按照存储方式分为<code>值类型</code>、<code>引用类型</code>：</p>
<p><code>值类型</code>分块存在内存空间， <code>引用类型</code>公用一块内存空间</p>
<h3 id="typeof">typeof</h3>
<p> <code>typeof</code> 只能打印出 <code>undefined</code>、<code>stirng</code>、<code>number</code>、<code>boolean</code>、<code>object</code>、<code>function</code></p>
<p><code>数组</code>、<code>对象</code>、<code>null</code> 打印的都是 <code>object</code></p>
<pre><code class="lang-JS">{
    console.log(typeof undefined) // undefined
    console.log(typeof &#39;str&#39;) // string
    console.log(typeof 2) // number
    console.log(typeof true) // boolean
    console.log(typeof {}) // object
    console.log(typeof []) // object
    console.log(typeof null) // object
    console.log(typeof console.log) // function
}
</code></pre>
<h3 id="-">=== 和 ==</h3>
<p><code>===</code> 会比较地址， <code>==</code> 只比较值</p>
<pre><code class="lang-JS">{
    // 1. 何时用 ==
    let obj = {};
    if (obj.a == null) {
        // 这里相当于 obj.a === null || obj.a === undefined 的简写形式，jquery 源码中推荐的写法
    }
}
</code></pre>
<h3 id="-">内置函数</h3>
<p><code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></p>
<h3 id="-">构造函数</h3>
<pre><code class="lang-JS">function Foo(name, age) {
    this.name = name;
    this.age = age;
    // return this  默认有这一行
}
var f = new Foo(&#39;zs&#39;, 20);
var f2 = new Foo(&#39;lisi&#39;, 20);
</code></pre>
<h3 id="-">构造函数扩展</h3>
<p><code>var a = {}</code> 其实是 <code>var a = new Object()</code> 的语法糖</p>
<p><code>var a = []</code> 其实是 <code>var a = new Array()</code> 的语法糖</p>
<p><code>function Foo(){...}</code> 其实是 <code>var Foo = new Function(...)</code></p>
<p>使用 <code>instanceof</code> 判断一个函数是否是一个变量的构造函数，或者说在不在一个原型链上 <code>instanceof Array</code></p>
<h3 id="-prototype-__proto__">原型规则 prototype、<strong>proto</strong></h3>
<ul>
<li>所有的引用类型(数组、对象、函数)，都有对象特性，即可自由扩展属性（除&#39;null&#39;）</li>
</ul>
<pre><code class="lang-JS">    var obj = {}; obj.a = 100;
    var arr = []; arr.a = 100;
    function fn(){}; fn.a = 100;
</code></pre>
<ul>
<li>所有的引用类型(数组、对象、函数)，都有一个 <code>__proto__</code>(隐式原型) 属性，属性值是一个普通的对象</li>
</ul>
<pre><code class="lang-JS">{
    var obj = {}; obj.a = 100;
    var arr = []; arr.a = 100;
    function fn(){}; fn.a = 100;

    console.log(obj.__proto__) // {}
    console.log(arr.__proto__) // []
    console.log(fn.__proto__) // [Function]
}
</code></pre>
<ul>
<li>所有的函数，都有一个 <code>prototype</code>(显示原型) 属性，属性值是一个普通的对象</li>
</ul>
<pre><code class="lang-JS">console.log(fn.prototype) // fn {}
</code></pre>
<ul>
<li><p>所有的引用类型(数组、对象、函数)， <code>__proto__</code> 属性值指向它的构造函数的 <code>prototype</code> 属性值</p>
<pre><code class="lang-JS">console.log(obj.__proto__ === Object.prototype) // true
</code></pre>
</li>
<li><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 <code>__proto__</code> (即它的构造函数的 <code>prototype</code>)中寻找</p>
</li>
</ul>
<pre><code class="lang-JS">{
    function Foo(name, age) {
        this.name = name
    }
    Foo.prototype.alertName = function () {
        console.log(this.name + &#39; alert&#39;)
    }
    var f = new Foo(&#39;zs&#39;)
    f.printName = function () {
        console.log(this.name + &#39; print&#39;)
    }
    f.printName() // zs print
    f.alertName() // zs alert

    console.log(f.__proto__ === Foo.prototype) // true

    // 遍历自身属性
    for (var item in f) {
        if (f.hasOwnProperty(item)) {
            console.log(item) // name printName
        }
    }
}
</code></pre>
<h3 id="-">原型链</h3>
<p><img src="/2017/11/02/面试整理1101/preview/面试整理/./面试整理/原型链.jpg" alt=""></p>
<p><img src="/2017/11/02/面试整理1101/preview/面试整理/./面试整理/原型链2.jpg" alt=""></p>
<ol>
<li><p>实例对象.<strong>proto</strong> 指向 构造函数.prototype （f.<strong>proto</strong> === Foo.prototype）</p>
</li>
<li><p>构造函数也是对象，对象有<strong>proto</strong> 属性 （Foo.prototype.<strong>proto</strong> === Object.prototype）</p>
</li>
</ol>
<pre><code class="lang-JS">    // 接上一题代码 
    f.toString() // 自身没有 toString()，要去 f.__proto__.__proto__ 中查找
    console.log(f.__proto__.__proto__ === Object.prototype) // true
</code></pre>
<h3 id="instanceof">instanceof</h3>
<p>用于判断 <code>引用类型</code> 属于哪个 <code>构造函数</code> 的方法</p>
<p>f 的 <strong>proto</strong> 一层一层网上，能否对应到 Foo.prototype</p>
<p>换句话： <code>f instanceof Foo</code> 为 <code>true</code>，表示 <code>Foo</code> 在 <code>f</code> 的原型链上</p>
<p><code>f instanceof Object</code> 也是 true</p>
<h3 id="-">判断变量是数组</h3>
<pre><code class="lang-JS">var arr = [];
arr instanceof Array // true
typeof arr // object
</code></pre>
<h3 id="-">原型链继承的例子</h3>
<pre><code class="lang-JS">{   // 动物
    function Animal(){
        this.eat = function(){
            console.log(&#39;animal eat&#39;)
        }
    }

    // 狗
    function Dog(){
        this.bark = function(){
            console.log(&#39;dog bark&#39;)
        }
    }

    Dog.prototype = new Animal()
    var hashiqi = new Dog

    hashiqi.eat() // animal eat，本身没有eat  
}
</code></pre>
<p>好的例子</p>
<pre><code class="lang-JS">{
    function Elem(id) {
        this.elem = document.getElementById(id)
    }

    Elem.prototype.html = function (val) {
        var elem = this.elem;
        if (val) {
            elem.innerHTML = val
            return this // 链式调用
        } else {
            return elem.innerHTML
        }
    }

    Elem.prototype.on = function (type, fn) {
        var elem = this.elem
        elem.addEventListener(type, fn)
    }

    var div1 = new Elem(&#39;div1&#39;)
    // console.log(div1.html())

    div1.html(&#39;&lt;p&gt;hello&lt;/p&gt;&#39;).on(&#39;click&#39;, function(){
        console.log(&#39;clicked&#39;)
    })
}
</code></pre>
<h3 id="new-">new 的过程</h3>
<ul>
<li><p>创建一个新对象</p>
</li>
<li><p>this 指向这个新对象</p>
</li>
<li><p>执行代码，对 this 赋值</p>
</li>
<li><p>返回 this</p>
</li>
</ul>
<pre><code class="lang-JS">{
    function Foo(name, age) {
        this.name = name;
        this.age = age;
        this.class = &#39;class-1&#39;
        // return this 默认有这一行
    }
    var f = new Foo(&#39;zs&#39;, 20);
    var f1 = new Foo(&#39;lisi&#39;, 22);
}
</code></pre>
<h3 id="-">执行上下文</h3>
<ul>
<li>范围：一段 <script> 或者一个函数</li>
<li>全局：变量定义、函数声明 </li>
<li>函数：变量定义、函数声明、this、arguments</li>
</ul>
<p>&quot;函数声明&quot; 和 &quot;函数表达式&quot; 区别</p>
<h3 id="this">this</h3>
<p>this 要在执行时才能确认值，定义时无法确认，（谁调用指向谁）</p>
<ul>
<li>作为构造函数执行</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call apply bind</li>
</ul>
<pre><code class="lang-JS">{
    var a = {
        name: &#39;A&#39;,
        fn: function () {
            console.log(this.name)
        }
    }
    a.fn() // this === a
    a.fn.call({ name: &#39;B&#39; }) // this === {name: &#39;B&#39;}
    var fn1 = a.fn
    fn1() // this === window
}
</code></pre>
<h3 id="call-apply-bind">call apply bind</h3>
<p>三个方法主要作用就是改变函数中 this 的指向</p>
<p><code>bind 是返回对应函数，便于稍后调用， apply、call 则是立即调用</code></p>
<pre><code class="lang-JS">{
    function fn(name, age) {
        console.log(this)
        console.log(name)
        console.log(age)
    }

    fn.call({ x: 100 }, &#39;zs&#39;, 20);

    // 第二个参数是数组
    fn.apply({ y: 200 }, [&#39;ls&#39;, 30]);

    var fn2 = function (name, age) {
        console.log(this)
        console.log(name)
        console.log(age)
    }.bind({ z: 300 })

    fn2(&#39;ww&#39;, 40)
}
</code></pre>
<h3 id="-">作用域</h3>
<p>一个函数的作用域，由定义的时候决定</p>
<ul>
<li>块级作用域</li>
</ul>
<p><code>ES6 之前无块级作用于， ES6 的 let、const会产生块级作用于</code></p>
<ul>
<li>函数和全局作用域</li>
</ul>
<pre><code class="lang-JS">{
    console.log(a); // undefined 
    var a = 100;

    fn(&#39;zs&#39;);

    function fn(name){
        console.log(this) // Window 或者 global
        console.log(arguments); // { &#39;0&#39;: &#39;zs&#39; }

        age = 20;
        console.log(name, age); // zs 20
        var age;

        bar(100);

        function bar(num){
            console.log(num) // 100
        }
    }
}
</code></pre>
<h3 id="-">作用域链</h3>
<p>向上查找，形成一条链</p>
<ul>
<li>自由变量，当前作用域没有定义的变量</li>
</ul>
<pre><code class="lang-JS">var a = 100;
function fn() {
    var b = 200;

    // 自由变量，当前作用域没有定义的变量
    console.log(a)

    console.log(b)
}
</code></pre>
<h3 id="-">闭包</h3>
<p>使用场景：</p>
<ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul>
<pre><code class="lang-JS">{
    function F1() {
        var a = 100;

        // 函数作为返回值
        return function () {
            console.log(a)
        }
    }

    // f1 得到一个函数
    var f1 = F1()
    var a = 200

    f1() // 100， 函数的作用域由定义的时候决定的， 所以 a 取的是 100
}

{   
    function F1() {
        var a = 100;
        return function () {
            console.log(a)
        }
    }
    var f1 = F1()

    function F2(fn) {
        var a = 200;
        fn()
    }

    // 当作参数传递
    F2(f1) // 100
}
</code></pre>
<p>实际应用：</p>
<pre><code class="lang-JS">{
    // 创建10个a标签，点击时候弹出对应序号
    var i;
    for (i = 0; i &lt; 10; i++) {
        (function (i) {
            var a = document.createElement(&#39;a&#39;)
            a.innerHTML = i + &#39;&lt;br&gt;&#39;
            a.addEventListener(&#39;click&#39;, function (e) {
                e.preventDefault()
                console.log(i)
            })
            document.body.appendChild(a)
        })(i)
    }
}
</code></pre>
<pre><code class="lang-JS">{   
    // 封装变量，收敛权限
    function isFirstLoad() {
        var _list = [];
        return function (id) {
            if (_list.indexOf(id) &gt;= 0) {
                return false;
            } else {
                _list.push(id);
                return true;
            }
        }
    }
    var firstLoad = isFirstLoad()
    console.log(firstLoad(10)) // true
    console.log(firstLoad(10)) // false
    console.log(firstLoad(20)) // true
    // 你在 isFirstLoad 函数外面，根本不可能修改掉 _list 的值
}
</code></pre>
<h3 id="-">异步和单线程</h3>
<ul>
<li>定时任务：setTimeout, setInterval</li>
<li>网络请求：ajax 请求， 动态 <img> 加载</li>
<li>事件绑定</li>
</ul>
<pre><code class="lang-JS">{   
    // 1. 异步
    console.log(100);
    setTimeout(function () {
        console.log(200);
    }, 1000)
    console.log(300)

    // 输出顺序：100 300 200

    // 2. 同步
    console.log(100)
    // alert(200)
    console.log(300)
}
</code></pre>
<p>同步异步区别：</p>
<ul>
<li><p>同步会阻塞代码执行，而异步不会</p>
</li>
<li><p>alert 是同步， setTimeout 是异步</p>
</li>
</ul>
<pre><code class="lang-JS">{
    console.log(1);

    setTimeout(function(){
        console.log(2)
    },0);

    console.log(3);

    setTimeout(function() {
        console.log(4)
    }, 1000);

    console.log(5)

    // 输出：1 3 5 2 4
}
</code></pre>
<h3 id="-math">日期和 Math</h3>
<pre><code class="lang-JS">{
    console.log(Date.now()) // 1509527636788, 获取当前时间毫秒数，1970年算起
    var dt = new Date();
    console.log(dt.getTime()); // 1509527636794, 获取当前时间毫秒数
    console.log(dt.getFullYear()) // 年
    console.log(dt.getMonth()) // 月（0-11）
    console.log(dt.getDate()) // 日（0-31）
    console.log(dt.getHours()) // 小时（0-23）
    console.log(dt.getMinutes()) // 分钟（0-59）
    console.log(dt.getSeconds()) // 秒（0-60）
}

{
Math.random()
}
</code></pre>
<h3 id="-api">数组和对象的 API</h3>
<ul>
<li>forEach 遍历所有元素</li>
<li>every 判断所有元素是否都符合条件</li>
<li>some 判断是否有至少一个元素符合条件</li>
<li>sort 排序</li>
<li>map 对元素重新组装，生成新数组</li>
<li>filter 过滤符合条件的元素</li>
</ul>
<pre><code class="lang-JS">{
    var arr = [1, 2, 3, 4];
    // forEach
    arr.forEach(function (item, index) {
        console.log(index, item);
    })

    // every
    var result = arr.every(function (item, index) {
        if (item &lt; 4) {
            return true;
        }
    })
    console.log(result); // false，有一个不符合

    // some
    var result2 = arr.some(function (item, index) {
        if (item &lt; 2) {
            return true;
        }
    })
    console.log(result2); // true，有一个符合

    // sort
    var arr2 = arr.sort(function (a, b) {
        return b - a; // 从大到小排序
    })
    console.log(arr2); // sort 参数是一个函数

    // map
    var arr3 = arr.map(function (item, index) {
        return &#39;&lt;br&gt;&#39; + item + &#39;&lt;/b&gt;&#39;; // 元素重新组装
    })
    console.log(arr3);

    // filter
    var arr4 = arr.filter(function (item, index) {
        if (item &gt;= 2) {
            return true
        }
    })
    console.log(arr4);
}
</code></pre>
<pre><code class="lang-JS">{
    var obj = {
        x: 100,
        y: 200,
        z: 300
    }
    var key
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            console.log(key, obj[key])
        }
    }
}
</code></pre>
<h3 id="-2017-06-10-">获取 2017-06-10 格式的日期</h3>
<pre><code class="lang-JS">{
    // 获取 2017-10-10 格式的日期
    function formatDate(dt) {
        if (!dt) {
            dt = new Date();
        }
        var year = dt.getFullYear();
        var month = dt.getMonth() + 1;
        var date = dt.getDate()
        if (month &lt; 10) {
            // 强制类型转换
            month = &#39;0&#39; + month;
        }
        if (date &lt; 10) {
            // 强制类型转换
            date = &#39;0&#39; + date
        }
        return year + &#39;-&#39; + month + &#39;-&#39; + date;
    }

    var dt = new Date()
    var fmtDate = formatDate(dt);
    console.log(fmtDate) // 2017-10-10
}
</code></pre>
<h3 id="-">获取长度一致的随机数</h3>
<pre><code class="lang-JS">{
    var random = Math.random();
    var random = random + &#39;0000000000&#39;; // 后面加 10 个 0
    var random = random.slice(0, 10); // 截取前十个
    console.log(random)
}
</code></pre>
<h3 id="-foreach">写一个遍历对象和数组的 forEach</h3>
<pre><code class="lang-JS">{
    function forEach(obj, fn) {
        var key;
        if (obj instanceof Array) {
            obj.forEach(function (item, index) {
                fn(index, item);
            })
        } else {
            for (key in obj) {
                fn(key, obj[key]);
            }
        }
    }

    // 测试

    var arr = [1, 2, 3];
    // 这里参数顺序换了，为了跟对象遍历一致
    forEach(arr, function (index, item) {
        console.log(index, item);
    })

    var obj = { x: 100, y: 200 };
    forEach(obj, function (key, value) {
        console.log(key, value)
    })
}
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<script type="text/javascript">
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</script></li></ul></article></div></div></body></html></div><div class="tags"></div><div class="post-nav"><a href="/2017/11/02/面试整理1101/preview/toc/css/demo/" class="pre"></a><a href="/2017/11/02/面试整理1101/preview/toc_conf/" class="next"></a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript-基础/">JavaScript 基础</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/书单/">书单</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/遇到的问题/">遇到的问题</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/书单/" style="font-size: 15px;">书单</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/遇到的问题/" style="font-size: 15px;">遇到的问题</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/网络基础/" style="font-size: 15px;">网络基础</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/makedownpad/">面试整理1101/preview/toc/style/makedownpad</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e/">面试整理1101/preview/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/GitHub2/">面试整理1101/preview/toc/style/GitHub2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5/">面试整理1101/preview/toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/GitHub/">面试整理1101/preview/toc/style/GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/js/ztree_toc.min/">面试整理1101/preview/toc/js/ztree_toc.min</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/Clearness Dark/">面试整理1101/preview/toc/style/Clearness Dark</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/style/Clearness/">面试整理1101/preview/toc/style/Clearness</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/js/ztree_toc/">面试整理1101/preview/toc/js/ztree_toc</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/面试整理1101/preview/toc/js/jquery.ztree.all-3.5.min/">面试整理1101/preview/toc/js/jquery.ztree.all-3.5.min</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Awoke.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" color="100,99,98" opacity="0.7" zIndex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>